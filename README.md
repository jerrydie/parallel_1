# Оценка максимальной производительности системы

## Вариант задания и используемые технологии

Номер в таблице 24: вариант 8 - выбор операции и ее векторного исполнения за студентов. Сделанный выбор - целочисленное умножение, векторное целочисленное умножение.

Формулировка задачи:

- Написать программу, выполняющую в цикле заданную арифметическую операцию.
- Замерить время выполнения цикла. По результатам замера получить оценку производительности микропроцессора на заданной операции (в тактах процессора):
1. используя последовательность зависимых операций ("латентность"),
2. используя последовательность независимых операций("темп выдачи результатов").

Для корректности теста необходимо добиться того, чтобы после компиляции внутри цикла не было обращений в память, и все вычисления проходили на регистрах. Полезно убедиться в этом путём анализа ассемблерного листинга. Кроме того, необходимо следить, чтобы компилятор не устранил из кода нужные операции. При необходимости можно использовать для тестирования модификацию ассемблерного листинга, сгенерированного компилятором.

Данный отчет включает: 

+ листинг программы на С++ (`src/main.cpp, src/format.hpp, src/format.cpp`);
+ листинг на ассемблере (`src/asm.asm`);
+ оценки производительности и их сравнение с теоретическими;
+ вывод по результатам задания.

Для векторизации вычислений использованы встроенные функции компилятора: 
- `_mm_set_epi32` для задания 128-битного вектора 32-битными целыми числами (SSE2),
- `_mm_mullo_epi32` для векторного перемножения 128-битных целочисленных векторов (SSE4.1),
- `_mm_extract_epi32` для получения из результирующего 128-битного вектора 32-юитных целых чисел (SSE4.1).

## Характеристики системы
```
cmd: lscpu output
```

|Характеристика                   |Значение
| ------------------------------- | -----------------------------------------
|Архитектура:                     |x86_64
|CPU op-mode(s):                  |32-bit, 64-bit
|Порядок байт:                    |Little Endian
|Address sizes:                   |39 bits physical, 48 bits virtual
|CPU(s):                          |1
|On-line CPU(s) list:             |0
|Потоков на ядро:                 |1
|Ядер на сокет:                   |1
|Сокетов:                         |1
|NUMA node(s):                    |1
|ID прроизводителя:               |GenuineIntel
|Семейство ЦПУ:                   |6
|Модель:                          |158
|Имя модели:                      |Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz
|Степпинг:                        |9
|CPU МГц:                         |2807.996

## Компиляция и создание ассемблерного листинга из исполняемого файла

```
cmd: cd project_folder/src
cmd: g++ main.cpp format.cpp -g -O0 -march=native -o test.o
cmd: objdump -S test.o > asm.asm

```

## Фрагменты ассемблерного кода с замеряемыми циклами

### SIMPLE MULTIPLICATION
```
  for (;iterator < operations; iterator++)
    2691:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
    2698:	48 3b 85 78 ff ff ff 	cmp    -0x88(%rbp),%rax
    269f:	73 1c                	jae    26bd <_ZL10simple_mulR9Mul_state+0xb2>
  	value1 *= value2; // зависимые операции
    26a1:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
    26a7:	0f af 85 4c ff ff ff 	imul   -0xb4(%rbp),%eax
    26ae:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
  for (;iterator < operations; iterator++)
    26b4:	48 ff 85 68 ff ff ff 	incq   -0x98(%rbp)
    26bb:	eb d4                	jmp    2691 <_ZL10simple_mulR9Mul_state+0x86>
```
Количество инструкций в одной операции - 8.
### SSE4.1 MULTIPLICATION

```
  for (;iterator < operations; iterator++)
    29de:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
    29e5:	48 3b 85 38 ff ff ff 	cmp    -0xc8(%rbp),%rax
    29ec:	73 38                	jae    2a26 <_ZL7sse_mulR9Mul_state+0x1a2>
    29ee:	c5 f9 6f 85 70 ff ff 	vmovdqa -0x90(%rbp),%xmm0
    29f5:	ff 
    29f6:	c5 f8 29 45 90       	vmovaps %xmm0,-0x70(%rbp)
    29fb:	c5 f9 6f 45 80       	vmovdqa -0x80(%rbp),%xmm0
    2a00:	c5 f8 29 45 a0       	vmovaps %xmm0,-0x60(%rbp)
/* Packed integer 32-bit multiplication with truncation of upper
   halves of results.  */
extern __inline __m128i __attribute__((__gnu_inline__, __always_inline__, __artificial__))
_mm_mullo_epi32 (__m128i __X, __m128i __Y)
{
  return (__m128i) ((__v4su)__X * (__v4su)__Y);
    2a05:	c5 f9 6f 4d 90       	vmovdqa -0x70(%rbp),%xmm1
    2a0a:	c5 f9 6f 45 a0       	vmovdqa -0x60(%rbp),%xmm0
    2a0f:	c4 e2 71 40 c0       	vpmulld %xmm0,%xmm1,%xmm0
    2a14:	90                   	nop
  	val1 = _mm_mullo_epi32(val1, val2); 
    2a15:	c5 f8 29 85 70 ff ff 	vmovaps %xmm0,-0x90(%rbp)
    2a1c:	ff 
  for (;iterator < operations; iterator++)
    2a1d:	48 ff 85 28 ff ff ff 	incq   -0xd8(%rbp)
    2a24:	eb b8                	jmp    29de <_ZL7sse_mulR9Mul_state+0x15a>
```
Количество инструкций в одной операции - 14.
## Результат измерений производитеьлности
```
cmd: ./test.o
```

### SIMPLE MULTIPLICATION
|     OPERATIONS     |        TIME        |       GFLOPS       |  PROCESSOR CLOCKS  |  CLOCK RATE, GHz   |        PACE        |        IPC         |     IPS, 10^9      |  OPERATION RESULT  |
|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|
|       10000        |      0.000020      |      0.506945      |       55109        |      2.793724      |      0.181459      |      1.451669      |      4.055561      |     1634275397     |
|       100000       |      0.000195      |      0.512707      |       547483       |      2.806986      |      0.182654      |      1.461233      |      4.101660      |     -20761979      |
|      1000000       |      0.003353      |      0.298214      |      9413695       |      2.807298      |      0.106228      |      0.849826      |      2.385714      |     2135439621     |
|      10000000      |      0.041604      |      0.240360      |     116750484      |      2.806216      |      0.085653      |      0.685222      |      1.922881      |     -217368059     |
|     100000000      |      0.298145      |      0.335407      |     837183873      |      2.807974      |      0.119448      |      0.955585      |      2.683257      |    -1867234299     |


### SSE4.1 MULTIPLICATION
|     OPERATIONS     |        TIME        |       GFLOPS       |  PROCESSOR CLOCKS  |  CLOCK RATE, GHz   |        PACE        |        IPC         |     IPS, 10^9      |  OPERATION RESULT  |
|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|--------------------|
|       10000        |      0.000013      |      0.755744      |       37036        |      2.798972      |      0.270008      |      3.780106      |     10.580411      |     1538795669     |
|       100000       |      0.000132      |      0.757823      |       370400       |      2.806975      |      0.269978      |      3.779698      |     10.609517      |     648736421      |
|      1000000       |      0.001679      |      0.595481      |      4714099       |      2.807156      |      0.212130      |      2.969815      |      8.336733      |    -1768532411     |
|      10000000      |      0.021827      |      0.458156      |      61283997      |      2.807763      |      0.163175      |      2.284446      |      6.414184      |     1749479045     |
|     100000000      |      0.260745      |      0.383517      |     732163463      |      2.807968      |      0.136582      |      1.912141      |      5.369231      |     -477523707     |


### Пояснения и выводы
- GFLOPS = `operations / (seconds*10^9)` - вычислительная способность, в нашем случае для операций с целыми числами (single precision -ish) (так как в распоряжении виртуальной машины только одно ядро, теор. значение с SSE4.1: `1*16*2.8=44.8 GFLOPS`, максимальное теоретическое значение же, с учетом того, что процессор имеет 4 ядра и поддерживает AVX2: `4*32*2.8=358,5 GFLOPS (single precision); 4*16*2.8=179.2 GFLOPS (double precision)`, если же вдобавок учесть, что возможно увеличить частоту процессора до 3.8 с помощью технологии Turbo Boost, то получим `486.4 (single)` и `243.2 (double)`, соответственно. Теоретическая производительность оказывается на порядки выше реальной, во-первых, потому что использована более слабая векторизация с помощью SSE4.1 вместо поддерживаемой AVX2, во-вторых, используется только одно ядро вместо потенциально доступных четырех, в-третьих, помимо данной программы компьютер выполняет множество других, которые также уменьшаяют практическую вычислительную способность, в-четвертых, выполняется только умножение, когда одновременно может выполняться еще и сложение, которое учитывается при вычислении теоретической производительности;

- CLOCK RATE - тактовая частота процессора, с увеличением количества операций стремится к заявленной частоте - 2807.996 МГц;

- PACE - среднее время, затрачиваемое на выполнение одной операции, в тактах процессора (латентность в простом случае/ темп выдачи результатов в случае SSE4.1), теоретическое максимальное значение можно посчитать как: `PROCESSOR CLOCKS / OPERATIONS = CLOCK RATE / GFLOPS = 2.8 / 486.4 = 0.0057757`, что на порядки меньше полученного по тем же причинам, что и для GFLOPS;

- IPC - количество ассемблерных инструкций, выполненных за один такт, является характеристикой выполнения конкретной программы на конкретном вычислительном устройстве;

- IPS - количество ассемблерных инструкций, выполненных за одну секунду `IPC*CLOCK RATE`, теоретически максимальное значение - `IPC*3.8 GHz`.

- TPP - теоретическая пиковая проихводительность (еще раз отдельно подробно вычислим): 4 (ядра) x 2 (юнита) x 8 (ширина вектора AVX2) x 2 (сложение и умножение в FMA) x 3.8 (GHz) = 486.4 GFLOPS.

Измерения показывают, что использование SSE4.1 векторизации дает небольшой прирост производительности в 1.5-1.2 раза.

# Освоение векторизации и распараллеливания программ на системе с общей памятью. 
 
## Цель 
Научиться выполнять оптимизацию (векторизация и распараллеливание на потоки) программ. 
 
## Постановка задачи 
Оптимизировать заданную программу автоматически или полуавтоматически с помощью  компилятора, а также при желании с помощью intrinsics. Сравнить времена работы следующих  вариантов программы: 
- исходная программа, без оптимизации 
- исходная программа, оптимизированная только с помощью ключей компилятора, 
- программа, векторизованная полуавтоматически (с помощью директив и ключей компилятора и незначительной правки кода), 
- программа, векторизованная и распараллеленная полуавтоматически 
 
Во всех случаях использовать ключи оптимизации, дающие наименьшее время работы программы,  и наиболее позднее (эффективное) из доступных векторных расширений. По возможности  обеспечить использование команд выровненного чтения и записи векторов. В программе с ручной  векторизацией минимизировать количество обращений к памяти. На каждом этапе ручной  оптимизации проверить, что время работы программы уменьшилось. 


